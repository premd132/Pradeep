<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kalyan AI Pattern - Final Correct Version</title>
<style>
    :root { --gold: #ffd700; --red: #ff0000; --bg: #000; --panel: #1a1a1a; }
    body { font-family: 'Courier New', Courier, monospace; background: var(--bg); color: #fff; margin: 0; padding: 10px; }
    
    .header { text-align: center; color: var(--gold); border-bottom: 2px solid #333; margin-bottom: 10px; padding: 10px; }
    .toolbar { display: flex; gap: 10px; justify-content: center; margin-bottom: 15px; }
    
    /* Chart Styles - Exactly like a Paper Chart */
    .table-container { position: relative; background: #fff; display: inline-block; border: 3px solid #555; }
    table { border-collapse: collapse; color: #000; font-size: 16px; }
    td, th { border: 1px solid #000; width: 45px; height: 45px; text-align: center; font-weight: bold; position: relative; }
    th { background: #b22222; color: #fff; font-size: 12px; }
    
    .circle { background: var(--red) !important; color: #fff !important; border-radius: 50%; z-index: 10; width: 35px; height: 35px; line-height: 35px; display: inline-block; }
    .blank { background: #ffffcc !important; cursor: pointer; border: 2px dashed #f00; }

    .dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-top: 20px; }
    .card { background: var(--panel); padding: 15px; border-radius: 10px; border: 1px solid var(--gold); }
    .card h3 { margin: 0 0 10px 0; color: var(--gold); text-align: center; border-bottom: 1px solid #444; }

    #matchList div { background: #333; margin: 5px 0; padding: 10px; cursor: pointer; border-radius: 5px; font-weight: bold; }
    #matchList div:hover { background: #444; color: var(--gold); }

    canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5; }
    button { background: var(--gold); color: #000; border: none; padding: 10px 15px; font-weight: bold; cursor: pointer; border-radius: 4px; }
</style>
</head>
<body>

<div class="header"><h1>KALYAN AI: REAL PATTERN SENSOR</h1></div>

<div class="toolbar">
    <button onclick="addRow()">‚ûï Add Week</button>
    <button onclick="saveData()" style="background:#28a745; color:#fff;">üíæ Save Data</button>
    <button onclick="clearData()" style="background:#d32f2f; color:#fff;">üóëÔ∏è Reset All</button>
</div>

<center>
    <div class="table-container" id="mainChart">
        <canvas id="lineCanvas"></canvas>
        <table id="tbl"></table>
    </div>
</center>

<div class="dashboard">
    <div class="card">
        <h3>üìç Patterns Found</h3>
        <div id="matchList">Click on a yellow box to analyze...</div>
    </div>
    <div class="card">
        <h3>üîÆ Prediction (Jodi)</h3>
        <div id="predictBox" style="font-size: 40px; color: var(--gold); text-align: center; margin-top: 10px;">--</div>
    </div>
</div>

<script>
const STORAGE_KEY = "kalyan_final_v7";
let data = JSON.parse(localStorage.getItem(STORAGE_KEY)) || [
    ["51","91","41","57","19","95"],
    ["05","90","74","06","19","63"],
    ["90","34","82","09","28","19"],
    ["**","**","**","**","**","**"]
];

let activeMatches = [];

function norm(v) { 
    v = String(v).trim(); 
    if(v === "" || v === "**") return "**";
    return v.length === 1 ? "0"+v : v;
}

function isLogicMatch(v1, v2) {
    if(v1 === "**" || v2 === "**") return false;
    // Direct, Palti, or Same Family
    if(v1 === v2 || v1 === v2.split('').reverse().join('')) return true;
    return false; // For accuracy, focusing on Direct/Palti
}

function draw() {
    let h = "<tr><th>MON</th><th>TUE</th><th>WED</th><th>THU</th><th>FRI</th><th>SAT</th></tr>";
    data.forEach((r, ri) => {
        h += "<tr>";
        r.forEach((c, ci) => {
            let cellContent = c;
            let cls = (c === "**") ? "blank" : "";
            // If part of active pattern, wrap in circle
            if(activeMatches.some(p => p.r === ri && p.c === ci)) {
                cellContent = `<span class="circle">${c}</span>`;
            }
            h += `<td class="${cls}" contenteditable="${c!=='**'}" oninput="edit(${ri},${ci},this)" 
                  onclick="${c === '**' ? `findRealPattern(${ri},${ci})` : ''}">${cellContent}</td>`;
        });
        h += "</tr>";
    });
    document.getElementById("tbl").innerHTML = h;
    if(activeMatches.length > 0) setTimeout(drawCanvasLines, 100);
}

function findRealPattern(r, c) {
    let matchesFound = [];
    // Video Logic: Look for repeating "gaps" in history
    for(let i = 0; i < r - 1; i++) {
        // Assume row 'i' was a previous target
        let potentialPoints = [];
        let score = 0;
        
        // Check 2 weeks above the historical point and current point
        for(let gap = 1; gap <= 3; gap++) {
            if(r-gap >= 0 && i-gap >= 0) {
                // Cross matching logic
                for(let col = 0; col < 6; col++) {
                    if(isLogicMatch(data[r-gap][col], data[i-gap][col])) {
                        potentialPoints.push({r: i-gap, c: col});
                        score++;
                    }
                }
            }
        }

        if(score >= 2) {
            matchesFound.push({targetRow: i, points: potentialPoints, score: score});
        }
    }
    updateUI(matchesFound, c);
}

function updateUI(matches, col) {
    let list = document.getElementById("matchList");
    list.innerHTML = "";
    
    matches.sort((a,b) => b.score - a.score).forEach(m => {
        let d = document.createElement("div");
        d.innerHTML = `Pattern Score: ${m.score} (Found at Week ${m.targetRow + 1})`;
        d.onclick = () => {
            activeMatches = m.points;
            draw();
            document.getElementById("predictBox").innerText = data[m.targetRow][col];
        };
        list.appendChild(d);
    });
}

function drawCanvasLines() {
    const cvs = document.getElementById("lineCanvas");
    const tbl = document.getElementById("tbl");
    const ctx = cvs.getContext("2d");
    cvs.width = tbl.offsetWidth; cvs.height = tbl.offsetHeight;
    ctx.clearRect(0,0, cvs.width, cvs.height);

    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    let rect = tbl.getBoundingClientRect();

    let circles = document.querySelectorAll(".circle");
    if(circles.length < 2) return;

    let first = circles[0].getBoundingClientRect();
    circles.forEach(c => {
        let r = c.getBoundingClientRect();
        ctx.beginPath();
        ctx.moveTo(first.left - rect.left + first.width/2, first.top - rect.top + first.height/2);
        ctx.lineTo(r.left - rect.left + r.width/2, r.top - rect.top + r.height/2);
        ctx.stroke();
    });
}

function edit(r,c,el) { data[r][c] = norm(el.innerText); }
function addRow() { data.push(["**","**","**","**","**","**"]); draw(); }
function saveData() { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); alert("Chart Saved!"); }
function clearData() { if(confirm("Reset entire chart?")) { localStorage.clear(); location.reload(); }}

draw();
</script>
</body>
</html>
